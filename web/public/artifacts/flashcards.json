[
  {
    "q": "What is the main purpose of a monotonic queue?",
    "a": "To efficiently find the minimum or maximum value in a sliding window in O(n) time",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-queue.md"
  },
  {
    "q": "What are the two main operations performed on a monotonic queue?",
    "a": "Push (add element while maintaining monotonic order) and Pop (remove element if outside window)",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-queue.md"
  },
  {
    "q": "What is the key property that makes monotonic queues efficient?",
    "a": "They maintain elements in increasing or decreasing order, allowing O(1) access to min/max",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-queue.md"
  },
  {
    "q": "When should you use a monotonic decreasing queue?",
    "a": "When you need to find the maximum value in each sliding window",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-queue.md"
  },
  {
    "q": "When should you use a monotonic increasing queue?",
    "a": "When you need to find the minimum value in each sliding window",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-queue.md"
  },
  {
    "q": "What is the time complexity for processing n elements with window size k using monotonic queue?",
    "a": "O(n) total time, O(k) space for the queue",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-queue.md"
  },
  {
    "q": "What happens when pushing an element to a monotonic decreasing queue?",
    "a": "Remove all elements smaller than the current element from the back before adding",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-queue.md"
  },
  {
    "q": "What happens when the front element goes out of the current window?",
    "a": "Remove it from the front of the queue",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-queue.md"
  },
  {
    "q": "What problem can be solved using dual monotonic queues (both min and max)?",
    "a": "Finding longest subarray where max - min ≤ limit",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-queue.md"
  },
  {
    "q": "What is the main advantage of monotonic queue over a regular sliding window approach?",
    "a": "O(1) time to get min/max per window instead of O(k) time",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-queue.md"
  },
  {
    "q": "What is the primary use case for a Difference Array?",
    "a": "Efficiently performing multiple range updates on an array or matrix (Write-Heavy).",
    "category": "algorithm",
    "source": "notes/algorithm/difference-array.md"
  },
  {
    "q": "What is the time complexity of a single update operation in a Difference Array?",
    "a": "$O(1)$",
    "category": "algorithm",
    "source": "notes/algorithm/difference-array.md"
  },
  {
    "q": "What operation is needed to retrieve the final values from a Difference Array after updates?",
    "a": "Prefix Sum (Integration)",
    "category": "algorithm",
    "source": "notes/algorithm/difference-array.md"
  },
  {
    "q": "How does the Difference Array update logic relate to 2D Prefix Sum query logic?",
    "a": "They are inverse operations; Difference Array updates 4 corners to \"mark\" changes, while Prefix Sum uses 4 corners (inclusion-exclusion) to \"read\" sums.",
    "category": "algorithm",
    "source": "notes/algorithm/difference-array.md"
  },
  {
    "q": "In a 1D Difference Array, to add `x` to range `[l, r]`, what two updates are made?",
    "a": "`diff[l] += x` and `diff[r+1] -= x`",
    "category": "algorithm",
    "source": "notes/algorithm/difference-array.md"
  },
  {
    "q": "What is the primary purpose of a segment tree?",
    "a": "To efficiently perform range queries (sum, min, max) and point updates on arrays",
    "category": "algorithm",
    "source": "notes/algorithm/segment-tree.md"
  },
  {
    "q": "What is the time complexity for building a segment tree?",
    "a": "O(n) where n is the size of the input array",
    "category": "algorithm",
    "source": "notes/algorithm/segment-tree.md"
  },
  {
    "q": "What is the time complexity for range queries in a segment tree?",
    "a": "O(log n) where n is the size of the input array",
    "category": "algorithm",
    "source": "notes/algorithm/segment-tree.md"
  },
  {
    "q": "What is the time complexity for point updates in a segment tree?",
    "a": "O(log n) where n is the size of the input array",
    "category": "algorithm",
    "source": "notes/algorithm/segment-tree.md"
  },
  {
    "q": "What is the space complexity of a segment tree?",
    "a": "O(4*n) or O(n) since we allocate space for 4*n nodes but many may not be used",
    "category": "algorithm",
    "source": "notes/algorithm/segment-tree.md"
  },
  {
    "q": "What technique is used for range updates in segment trees?",
    "a": "Lazy propagation to mark nodes for future updates",
    "category": "algorithm",
    "source": "notes/algorithm/segment-tree.md"
  },
  {
    "q": "What is the main advantage of segment trees over simple array traversal for range queries?",
    "a": "Logarithmic time complexity instead of linear time for each query",
    "category": "algorithm",
    "source": "notes/algorithm/segment-tree.md"
  },
  {
    "q": "What type of problems commonly require segment trees?",
    "a": "Problems with frequent range sum/min/max queries and point updates",
    "category": "algorithm",
    "source": "notes/algorithm/segment-tree.md"
  },
  {
    "q": "How does a segment tree represent the array?",
    "a": "As a binary tree where each node represents a segment of the array",
    "category": "algorithm",
    "source": "notes/algorithm/segment-tree.md"
  },
  {
    "q": "What happens during a range query in a segment tree?",
    "a": "The query recursively traverses the tree, combining results from child nodes",
    "category": "algorithm",
    "source": "notes/algorithm/segment-tree.md"
  },
  {
    "q": "What is the primary purpose of Union-Find (Disjoint Set Union)?",
    "a": "To efficiently manage disjoint sets and perform union and find operations",
    "category": "algorithm",
    "source": "notes/algorithm/union-find-dsu.md"
  },
  {
    "q": "What are the two main operations in Union-Find?",
    "a": "Find (determine which set an element belongs to) and Union (merge two sets)",
    "category": "algorithm",
    "source": "notes/algorithm/union-find-dsu.md"
  },
  {
    "q": "What optimization techniques are used to achieve nearly constant time operations?",
    "a": "Path compression and union by rank or size",
    "category": "algorithm",
    "source": "notes/algorithm/union-find-dsu.md"
  },
  {
    "q": "What is path compression in Union-Find?",
    "a": "Making each node on the find path point directly to the root to flatten the tree structure",
    "category": "algorithm",
    "source": "notes/algorithm/union-find-dsu.md"
  },
  {
    "q": "What is union by rank in Union-Find?",
    "a": "Always attaching the smaller tree to the root of the larger tree to keep trees balanced",
    "category": "algorithm",
    "source": "notes/algorithm/union-find-dsu.md"
  },
  {
    "q": "What is the time complexity of Union-Find operations with optimizations?",
    "a": "Nearly O(α(n)) where α(n) is the inverse Ackermann function (effectively constant)",
    "category": "algorithm",
    "source": "notes/algorithm/union-find-dsu.md"
  },
  {
    "q": "What famous algorithm uses Union-Find as a key component?",
    "a": "Kruskal's algorithm for finding Minimum Spanning Trees",
    "category": "algorithm",
    "source": "notes/algorithm/union-find-dsu.md"
  },
  {
    "q": "What type of graph problem is Union-Find particularly good for?",
    "a": "Connected components and cycle detection in undirected graphs",
    "category": "algorithm",
    "source": "notes/algorithm/union-find-dsu.md"
  },
  {
    "q": "What happens when you try to union two elements that are already in the same set?",
    "a": "The operation returns false and no change is made",
    "category": "algorithm",
    "source": "notes/algorithm/union-find-dsu.md"
  },
  {
    "q": "What is the main advantage of Union-Find over other data structures for connectivity queries?",
    "a": "Extremely fast operations that are nearly constant time for practical purposes",
    "category": "algorithm",
    "source": "notes/algorithm/union-find-dsu.md"
  },
  {
    "q": "What is the primary purpose of a monotonic stack?",
    "a": "To efficiently find the next greater or next smaller element for each element in an array",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-stack.md"
  },
  {
    "q": "What are the two main types of monotonic stacks?",
    "a": "Increasing monotonic stack (for next smaller elements) and decreasing monotonic stack (for next greater elements)",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-stack.md"
  },
  {
    "q": "What happens when we push an element onto a decreasing monotonic stack?",
    "a": "We pop all elements that are smaller than the current element before pushing",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-stack.md"
  },
  {
    "q": "What happens when we push an element onto an increasing monotonic stack?",
    "a": "We pop all elements that are larger than the current element before pushing",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-stack.md"
  },
  {
    "q": "What is the time complexity of processing n elements with a monotonic stack?",
    "a": "O(n) because each element is pushed and popped at most once",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-stack.md"
  },
  {
    "q": "What famous problem can be solved using a monotonic stack?",
    "a": "Largest Rectangle in Histogram (LeetCode 84)",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-stack.md"
  },
  {
    "q": "What is the key insight behind monotonic stacks for histogram problems?",
    "a": "Each bar can extend to the left until it hits a taller bar, and to the right until it hits a taller bar",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-stack.md"
  },
  {
    "q": "What problem involves finding how many days you have to wait for a warmer temperature?",
    "a": "Daily Temperatures (LeetCode 739)",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-stack.md"
  },
  {
    "q": "What data structure is commonly used to implement monotonic stacks?",
    "a": "A regular stack, but with the monotonic property maintained during push operations",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-stack.md"
  },
  {
    "q": "What is the main advantage of monotonic stacks over brute force approaches?",
    "a": "They solve next greater/smaller element problems in linear time instead of quadratic time",
    "category": "algorithm",
    "source": "notes/algorithm/monotonic-stack.md"
  },
  {
    "q": "What is the main difference between BFS and DFS in terms of exploration strategy?",
    "a": "BFS explores level by level (breadth-first), while DFS explores as far as possible along a branch (depth-first)",
    "category": "algorithm",
    "source": "notes/algorithm/graph-search-algorithms.md"
  },
  {
    "q": "What is the time complexity of BFS on a graph with V vertices and E edges?",
    "a": "O(V + E) for both time and space in the worst case",
    "category": "algorithm",
    "source": "notes/algorithm/graph-search-algorithms.md"
  },
  {
    "q": "When should you use Dijkstra's algorithm instead of BFS?",
    "a": "When edges have non-negative weights greater than 1, or when you need to find shortest paths in weighted graphs",
    "category": "algorithm",
    "source": "notes/algorithm/graph-search-algorithms.md"
  },
  {
    "q": "What optimization does Union-Find use to achieve nearly constant time operations?",
    "a": "Path compression and union by rank/size",
    "category": "algorithm",
    "source": "notes/algorithm/graph-search-algorithms.md"
  },
  {
    "q": "What is the key difference between A* search and Dijkstra's algorithm?",
    "a": "A* uses a heuristic function to guide the search toward the target, while Dijkstra explores uniformly",
    "category": "algorithm",
    "source": "notes/algorithm/graph-search-algorithms.md"
  },
  {
    "q": "When is 0-1 BFS more appropriate than regular BFS?",
    "a": "When edge weights are only 0 or 1, allowing for more efficient shortest path computation",
    "category": "algorithm",
    "source": "notes/algorithm/graph-search-algorithms.md"
  },
  {
    "q": "What makes minimax algorithm suitable for two-player games?",
    "a": "It assumes both players play optimally and explores all possible future moves",
    "category": "algorithm",
    "source": "notes/algorithm/graph-search-algorithms.md"
  },
  {
    "q": "What data structure is commonly used to implement BFS?",
    "a": "Queue (FIFO - First In, First Out)",
    "category": "algorithm",
    "source": "notes/algorithm/graph-search-algorithms.md"
  },
  {
    "q": "What data structure is commonly used to implement DFS?",
    "a": "Stack (LIFO - Last In, First Out) or recursion",
    "category": "algorithm",
    "source": "notes/algorithm/graph-search-algorithms.md"
  },
  {
    "q": "What is the primary use case for Union-Find?",
    "a": "Managing disjoint sets and connectivity queries in graphs",
    "category": "algorithm",
    "source": "notes/algorithm/graph-search-algorithms.md"
  },
  {
    "q": "What type of algorithm is minimax and what games is it typically used for?",
    "a": "Minimax is a decision-making algorithm for two-player turn-based games where both players play optimally",
    "category": "algorithm",
    "source": "notes/algorithm/minimax-algorithm.md"
  },
  {
    "q": "What are the two main player types in minimax algorithm?",
    "a": "Maximizing player (tries to maximize score) and minimizing player (tries to minimize score)",
    "category": "algorithm",
    "source": "notes/algorithm/minimax-algorithm.md"
  },
  {
    "q": "What is the key assumption that minimax makes about player behavior?",
    "a": "Both players play optimally, making the best possible moves at each turn",
    "category": "algorithm",
    "source": "notes/algorithm/minimax-algorithm.md"
  },
  {
    "q": "What technique is commonly used to optimize minimax algorithm?",
    "a": "Alpha-beta pruning to eliminate branches that won't affect the final decision",
    "category": "algorithm",
    "source": "notes/algorithm/minimax-algorithm.md"
  },
  {
    "q": "What is the time complexity of minimax without optimization?",
    "a": "O(b^d) where b is branching factor and d is depth, exponential in the worst case",
    "category": "algorithm",
    "source": "notes/algorithm/minimax-algorithm.md"
  },
  {
    "q": "What data structure or technique can help avoid recomputing game states in minimax?",
    "a": "Memoization or transposition tables to cache evaluated positions",
    "category": "algorithm",
    "source": "notes/algorithm/minimax-algorithm.md"
  },
  {
    "q": "What is the main purpose of the minimax algorithm in game theory?",
    "a": "To determine the best move for a player assuming optimal play from both sides",
    "category": "algorithm",
    "source": "notes/algorithm/minimax-algorithm.md"
  },
  {
    "q": "How does minimax determine which move to choose at each step?",
    "a": "It evaluates all possible future moves recursively and chooses the move that leads to the best outcome",
    "category": "algorithm",
    "source": "notes/algorithm/minimax-algorithm.md"
  },
  {
    "q": "What happens at terminal nodes (game over states) in minimax?",
    "a": "The algorithm returns the evaluated score of that position",
    "category": "algorithm",
    "source": "notes/algorithm/minimax-algorithm.md"
  },
  {
    "q": "What is a key limitation of the basic minimax algorithm?",
    "a": "It becomes computationally expensive for games with high branching factors or deep search depths",
    "category": "algorithm",
    "source": "notes/algorithm/minimax-algorithm.md"
  },
  {
    "q": "What is the time complexity for building a 2D prefix sum array?",
    "a": "O(m * n) where m and n are the dimensions of the matrix",
    "category": "algorithm",
    "source": "notes/algorithm/2d-prefix-sum.md"
  },
  {
    "q": "What is the time complexity for querying a submatrix sum using 2D prefix sum?",
    "a": "O(1) constant time",
    "category": "algorithm",
    "source": "notes/algorithm/2d-prefix-sum.md"
  },
  {
    "q": "What is the formula for computing prefix_sum\\[i]\\[j] in a 2D prefix sum array?",
    "a": "prefix_sum\\[i]\\[j] = matrix\\[i]\\[j] + prefix_sum\\[i-1]\\[j] + prefix_sum\\[i]\\[j-1] - prefix_sum\\[i-1]\\[j-1]",
    "category": "algorithm",
    "source": "notes/algorithm/2d-prefix-sum.md"
  },
  {
    "q": "What adjustment is needed when querying a submatrix that doesn't start at (0,0)?",
    "a": "Subtract the sums of the regions above and to the left, and add back the overlapping corner region",
    "category": "algorithm",
    "source": "notes/algorithm/2d-prefix-sum.md"
  },
  {
    "q": "What is the main advantage of using 2D prefix sums over nested loops for range queries?",
    "a": "O(1) query time instead of O(m \\* n) for each query where m\\*n is the submatrix size",
    "category": "algorithm",
    "source": "notes/algorithm/2d-prefix-sum.md"
  },
  {
    "q": "What is the main advantage of the KMP algorithm over naive string matching?",
    "a": "KMP avoids redundant comparisons by using the LPS array to skip unnecessary character checks",
    "category": "algorithm",
    "source": "notes/algorithm/kmp-algorithm.md"
  },
  {
    "q": "What does LPS stand for in the KMP algorithm?",
    "a": "Longest Proper Prefix which is also Suffix",
    "category": "algorithm",
    "source": "notes/algorithm/kmp-algorithm.md"
  },
  {
    "q": "What is the time complexity of the KMP algorithm for pattern matching?",
    "a": "O(n + m) where n is text length and m is pattern length",
    "category": "algorithm",
    "source": "notes/algorithm/kmp-algorithm.md"
  },
  {
    "q": "What is the space complexity of the KMP algorithm?",
    "a": "O(m) for the LPS array where m is pattern length",
    "category": "algorithm",
    "source": "notes/algorithm/kmp-algorithm.md"
  },
  {
    "q": "In KMP, what happens when a mismatch occurs at position j in the pattern?",
    "a": "We use the LPS array to determine how far back to go in the pattern (to position lps\\[j-1])",
    "category": "algorithm",
    "source": "notes/algorithm/kmp-algorithm.md"
  },
  {
    "q": "What is the key insight that makes KMP more efficient than naive matching?",
    "a": "The pattern itself contains information about how to shift when mismatches occur",
    "category": "algorithm",
    "source": "notes/algorithm/kmp-algorithm.md"
  },
  {
    "q": "How does KMP preprocessing work for the pattern \"ABABAC\"?",
    "a": "Build LPS array where each position shows longest proper prefix that is also suffix",
    "category": "algorithm",
    "source": "notes/algorithm/kmp-algorithm.md"
  },
  {
    "q": "What is the worst-case scenario for KMP algorithm efficiency?",
    "a": "When the pattern consists of many repeated characters, but KMP still maintains O(n + m) worst case",
    "category": "algorithm",
    "source": "notes/algorithm/kmp-algorithm.md"
  },
  {
    "q": "How many comparisons does KMP make in the worst case?",
    "a": "O(n + m) total comparisons, much better than naive O(n * m)",
    "category": "algorithm",
    "source": "notes/algorithm/kmp-algorithm.md"
  },
  {
    "q": "What preprocessing step makes KMP efficient?",
    "a": "Computing the LPS (failure function) array that tells us where to jump when mismatches occur",
    "category": "algorithm",
    "source": "notes/algorithm/kmp-algorithm.md"
  },
  {
    "q": "What is the main use case for Reservoir Sampling?",
    "a": "Selecting a random sample of $k$ items from a **stream of unknown size** or a dataset too large to fit in memory.",
    "category": "algorithm",
    "source": "notes/algorithm/reservoir-sampling.md"
  },
  {
    "q": "What is the time complexity of Reservoir Sampling?",
    "a": "**O(N)** (single pass over the data).",
    "category": "algorithm",
    "source": "notes/algorithm/reservoir-sampling.md"
  },
  {
    "q": "What is the space complexity of Reservoir Sampling?",
    "a": "**O(k)** (size of the sample).",
    "category": "algorithm",
    "source": "notes/algorithm/reservoir-sampling.md"
  },
  {
    "q": "When processing the $i$-th element (where $i > k$), with what probability should we keep it?",
    "a": "Probability **$k/i$**.",
    "category": "algorithm",
    "source": "notes/algorithm/reservoir-sampling.md"
  },
  {
    "q": "If we decide to keep the $i$-th element, which element do we replace?",
    "a": "A **randomly selected** element from the existing reservoir (index $0$ to $k-1$).",
    "category": "algorithm",
    "source": "notes/algorithm/reservoir-sampling.md"
  },
  {
    "q": "What is the primary constraint in an RTB system?",
    "a": "**Latency** (typically < 100ms total, < 50ms internal).",
    "category": "system-design",
    "source": "notes/system-design/design-real-time-bidding-rtb-system.md"
  },
  {
    "q": "What database type is best for User Profile lookups in RTB?",
    "a": "**Key-Value Stores** like Redis or Aerospike (low latency, high throughput).",
    "category": "system-design",
    "source": "notes/system-design/design-real-time-bidding-rtb-system.md"
  },
  {
    "q": "How do we handle heavy ML inference within 20ms?",
    "a": "Use a **Cascade** (light model for filtration, heavy model for ranking) or optimize model serving (quantization, compilation).",
    "category": "system-design",
    "source": "notes/system-design/design-real-time-bidding-rtb-system.md"
  },
  {
    "q": "What is \"Pacing\" in AdTech?",
    "a": "Spreading an advertiser's budget evenly throughout the day so they don't spend it all in the first hour.",
    "category": "system-design",
    "source": "notes/system-design/design-real-time-bidding-rtb-system.md"
  },
  {
    "q": "Why is distributed budget management difficult?",
    "a": "Because locking a central database for every bid is too slow; we use **local allocation** and **batch synchronization**.",
    "category": "system-design",
    "source": "notes/system-design/design-real-time-bidding-rtb-system.md"
  },
  {
    "q": "What is Training-Serving Skew?",
    "a": "The performance degradation caused when production data/logic differs from training data/logic.",
    "category": "system-design",
    "source": "notes/system-design/feature-stores-training-serving-skew.md"
  },
  {
    "q": "What is the main responsibility of a Feature Store?",
    "a": "To serve consistent feature values to both **offline training** and **online inference** environments.",
    "category": "system-design",
    "source": "notes/system-design/feature-stores-training-serving-skew.md"
  },
  {
    "q": "What is Point-in-Time (PIT) Correctness?",
    "a": "Ensuring that historical training data only uses feature values that were actually available **before** the event timestamp (no future leakage).",
    "category": "system-design",
    "source": "notes/system-design/feature-stores-training-serving-skew.md"
  },
  {
    "q": "Which database type is typically used for the \"Online Store\"?",
    "a": "Low-latency Key-Value stores (Redis, DynamoDB, Cassandra).",
    "category": "system-design",
    "source": "notes/system-design/feature-stores-training-serving-skew.md"
  },
  {
    "q": "Which database type is typically used for the \"Offline Store\"?",
    "a": "Scalable Data Warehouses or Data Lakes (BigQuery, Snowflake, S3/Parquet).",
    "category": "system-design",
    "source": "notes/system-design/feature-stores-training-serving-skew.md"
  },
  {
    "q": "What is Data Drift (Covariate Shift)?",
    "a": "A change in the distribution of **input features** $P(X)$, while the underlying relationship to the target stays the same.",
    "category": "system-design",
    "source": "notes/system-design/ml-model-monitoring-data-concept-drift.md"
  },
  {
    "q": "What is Concept Drift?",
    "a": "A change in the **relationship** between inputs and the target variable $P(Y|X)$ (e.g., user preferences change).",
    "category": "system-design",
    "source": "notes/system-design/ml-model-monitoring-data-concept-drift.md"
  },
  {
    "q": "What is PSI (Population Stability Index)?",
    "a": "A metric used to quantify how much a variable's distribution has shifted between two time periods (e.g., Training vs. Production).",
    "category": "system-design",
    "source": "notes/system-design/ml-model-monitoring-data-concept-drift.md"
  },
  {
    "q": "Why is monitoring Concept Drift harder than Data Drift?",
    "a": "Because Concept Drift detection usually requires **ground truth labels**, which may be delayed or unavailable in production, whereas Data Drift only looks at inputs.",
    "category": "system-design",
    "source": "notes/system-design/ml-model-monitoring-data-concept-drift.md"
  },
  {
    "q": "What is the typical threshold for PSI to indicate \"Significant Drift\"?",
    "a": "A PSI value greater than **0.2**.",
    "category": "system-design",
    "source": "notes/system-design/ml-model-monitoring-data-concept-drift.md"
  },
  {
    "q": "What is the main trade-off in Approximate Nearest Neighbor (ANN) search?",
    "a": "Trading a small amount of **Accuracy/Recall** (missing the absolute best match) for massive gains in **Speed** ($O(N) \\rightarrow O(\\log N)$).",
    "category": "system-design",
    "source": "notes/system-design/embedding-search-engines-vector-dbs.md"
  },
  {
    "q": "How does HNSW (Hierarchical Navigable Small World) work?",
    "a": "It builds a multi-layered graph where upper layers have long connections (highways) for fast traversal and lower layers have short connections for precise local search.",
    "category": "system-design",
    "source": "notes/system-design/embedding-search-engines-vector-dbs.md"
  },
  {
    "q": "What is the \"Voronoi Cell\" concept in IVF indexing?",
    "a": "Partitioning the vector space into regions (cells) around centroids; during search, we only look at vectors inside the cell closest to the query.",
    "category": "system-design",
    "source": "notes/system-design/embedding-search-engines-vector-dbs.md"
  },
  {
    "q": "Which similarity metric is best when vector magnitude should be ignored (only direction matters)?",
    "a": "**Cosine Similarity**.",
    "category": "system-design",
    "source": "notes/system-design/embedding-search-engines-vector-dbs.md"
  },
  {
    "q": "What is `nprobe` in Faiss IVF?",
    "a": "A hyperparameter that determines how many adjacent clusters (cells) to search. Higher `nprobe` increases accuracy but decreases speed.",
    "category": "system-design",
    "source": "notes/system-design/embedding-search-engines-vector-dbs.md"
  },
  {
    "q": "What is the main purpose of Docker containers?",
    "a": "To package applications and their dependencies into lightweight, portable, and isolated environments",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What is a Docker image?",
    "a": "A read-only template that contains the application code, runtime, libraries, and configuration files needed to run a container",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What is a Docker container?",
    "a": "A runnable instance of a Docker image that provides an isolated process with its own filesystem and network",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What is the purpose of a Dockerfile?",
    "a": "To define the steps needed to create a Docker image through a series of instructions",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What is the difference between a Docker image and a container?",
    "a": "An image is the static blueprint/template, while a container is the running instance created from that image",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What are the main benefits of using Docker?",
    "a": "Portability, consistency across environments, isolation, scalability, and simplified dependency management",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What is Docker Compose used for?",
    "a": "To define and run multi-container Docker applications using a YAML configuration file",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What is the purpose of Docker volumes?",
    "a": "To persist data generated by and used by Docker containers beyond their lifecycle",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What is the difference between COPY and ADD instructions in Dockerfile?",
    "a": "COPY copies files from host to image, while ADD can also download files from URLs and extract archives",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What is the purpose of the EXPOSE instruction in Dockerfile?",
    "a": "To inform Docker that the container listens on specified network ports at runtime",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What is the difference between ENTRYPOINT and CMD in Dockerfile?",
    "a": "ENTRYPOINT defines the executable, while CMD provides default arguments that can be overridden",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What is Docker layering?",
    "a": "The concept where each Dockerfile instruction creates a new layer in the image, allowing for caching and reusability",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What is the purpose of multi-stage builds in Docker?",
    "a": "To create smaller, more efficient images by using multiple FROM statements and copying only necessary artifacts",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What is the role of a Docker registry?",
    "a": "To store, distribute, and manage Docker images across different environments and teams",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What are some common Docker security best practices?",
    "a": "Run containers as non-root users, use minimal base images, scan for vulnerabilities, and limit resource usage",
    "category": "devops",
    "source": "notes/devops/docker-containers.md"
  },
  {
    "q": "What is the primary purpose of Kubernetes?",
    "a": "To automate deployment, scaling, and management of containerized applications",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What is a Pod in Kubernetes?",
    "a": "The smallest deployable unit that can contain one or more containers that share storage and network",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What is the role of the Kubernetes API Server?",
    "a": "To serve as the central management point for the entire cluster, handling all administrative operations",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What is the purpose of a Deployment in Kubernetes?",
    "a": "To manage stateless applications, providing declarative updates and scaling capabilities",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What is a Service in Kubernetes?",
    "a": "An abstraction that defines a logical set of Pods and enables network access to them",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What is the purpose of an Ingress in Kubernetes?",
    "a": "To manage external access to services, typically handling HTTP/HTTPS traffic and load balancing",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What is the role of etcd in Kubernetes?",
    "a": "To store the entire cluster state and configuration data reliably and consistently",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What is the purpose of a ReplicaSet in Kubernetes?",
    "a": "To ensure that a specified number of pod replicas are running at all times",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What is the role of the Kubelet in Kubernetes?",
    "a": "To run on each worker node and ensure containers are running in Pods as expected",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What is the purpose of a ConfigMap in Kubernetes?",
    "a": "To store configuration data as key-value pairs that can be consumed by pods",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What is the difference between a Deployment and a StatefulSet?",
    "a": "Deployments manage stateless apps with rolling updates, while StatefulSets manage stateful apps with stable identities",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What is the purpose of a Namespace in Kubernetes?",
    "a": "To provide a mechanism for isolating groups of resources within a single cluster",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What is the role of the Kubernetes Scheduler?",
    "a": "To assign pods to nodes based on resource requirements and constraints",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What is the purpose of a PersistentVolume in Kubernetes?",
    "a": "To provide an abstraction for storage that persists beyond the lifecycle of individual pods",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What are the main components of the Kubernetes control plane?",
    "a": "API Server, etcd, Controller Manager, and Scheduler",
    "category": "devops",
    "source": "notes/devops/kubernetes-orchestration.md"
  },
  {
    "q": "What does CI/CD stand for in software development?",
    "a": "Continuous Integration / Continuous Deployment",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What is the main goal of Continuous Integration?",
    "a": "To integrate code changes frequently and detect integration issues early through automated testing",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What is the primary benefit of Continuous Deployment?",
    "a": "Automated deployment of every code change that passes all tests to production",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What are the core stages of a typical CI/CD pipeline?",
    "a": "Build, Test, Deploy, Monitor",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What is the purpose of a build stage in CI/CD?",
    "a": "To compile source code and create deployable artifacts like Docker images",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What type of testing is typically performed in the CI stage?",
    "a": "Unit tests, integration tests, and static code analysis",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What is the role of artifact repositories in CI/CD?",
    "a": "To store and version build artifacts, dependencies, and deployment packages",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What is infrastructure as code in the context of CI/CD?",
    "a": "Managing and provisioning infrastructure through machine-readable definition files",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What is the purpose of blue-green deployment?",
    "a": "To reduce downtime by running two identical production environments and switching between them",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What is canary deployment?",
    "a": "Gradually rolling out changes to a small subset of users before full deployment",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What is the main advantage of feature flags in CI/CD?",
    "a": "To enable/disable features without redeploying, allowing for safer releases",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What is the purpose of automated rollback in CI/CD?",
    "a": "To quickly revert to a previous working version if issues are detected post-deployment",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What is the difference between Continuous Delivery and Continuous Deployment?",
    "a": "Continuous Delivery requires manual approval for production deployment, while Continuous Deployment is fully automated",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What is the role of monitoring in CI/CD pipelines?",
    "a": "To track deployment success, application health, and provide feedback for continuous improvement",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What is a common challenge with CI/CD pipelines?",
    "a": "Managing environment drift between development, staging, and production environments",
    "category": "devops",
    "source": "notes/devops/cicd-pipelines.md"
  },
  {
    "q": "What is the main benefit of Recursive Character Chunking over Fixed-Size Chunking?",
    "a": "It attempts to keep related text together (paragraphs, sentences) rather than splitting mid-sentence, preserving **semantic meaning**.",
    "category": "agentic",
    "source": "notes/agentic/rag-architectures-chunking.md"
  },
  {
    "q": "Why is Hybrid Search often better than pure Vector Search?",
    "a": "Vector search can fail on **exact keyword matches** (like part numbers or acronyms), which BM25/Keyword search handles well.",
    "category": "agentic",
    "source": "notes/agentic/rag-architectures-chunking.md"
  },
  {
    "q": "What is the role of a Re-Ranker (Cross-Encoder) in RAG?",
    "a": "It takes a broad set of candidate results and re-scores them with high precision to select the best few for the LLM, improving relevance.",
    "category": "agentic",
    "source": "notes/agentic/rag-architectures-chunking.md"
  },
  {
    "q": "What is \"Parent-Child\" indexing?",
    "a": "Searching against small, precise chunks (Children) but returning larger, surrounding context (Parent) to the LLM.",
    "category": "agentic",
    "source": "notes/agentic/rag-architectures-chunking.md"
  },
  {
    "q": "What is Reciprocal Rank Fusion (RRF)?",
    "a": "An algorithm to combine ranked lists from different search methods (e.g., BM25 and Vector Search) into a single unified ranking.",
    "category": "agentic",
    "source": "notes/agentic/rag-architectures-chunking.md"
  },
  {
    "q": "What is the first command to run in the Spec Kit workflow?",
    "a": "`/speckit.specify`",
    "category": "agentic",
    "source": "notes/agentic/spec-kit-interview-strategy.md"
  },
  {
    "q": "Why is the `constitution.md` file important?",
    "a": "It defines the \"rules of engagement\" for the AI (e.g., \"use single file\", \"explain Big-O\"), preventing it from over-engineering or missing requirements.",
    "category": "agentic",
    "source": "notes/agentic/spec-kit-interview-strategy.md"
  },
  {
    "q": "If the AI generates an over-complicated plan (e.g., using PostgreSQL), what should you do?",
    "a": "**Interrupt and Refine**: Tell it to use a simpler alternative like SQLite or in-memory structures appropriate for a 30-minute interview.",
    "category": "agentic",
    "source": "notes/agentic/spec-kit-interview-strategy.md"
  },
  {
    "q": "What are the three main steps in the Spec Kit loop?",
    "a": "**Specify** (Requirements), **Plan** (Architecture), **Implement** (Code Generation).",
    "category": "agentic",
    "source": "notes/agentic/spec-kit-interview-strategy.md"
  },
  {
    "q": "What should you do if the task is trivial (e.g., \"reverse a string\")?",
    "a": "Skip Spec Kit and use standard Cursor Chat or Composer to avoid unnecessary overhead.",
    "category": "agentic",
    "source": "notes/agentic/spec-kit-interview-strategy.md"
  },
  {
    "q": "What is the core idea of Chain of Thought (CoT)?",
    "a": "It encourages the LLM to generate **intermediate reasoning steps** before the final answer, which improves performance on complex tasks.",
    "category": "agentic",
    "source": "notes/agentic/agent-reasoning-patterns-react-cot.md"
  },
  {
    "q": "What does ReAct stand for?",
    "a": "**Re**asoning + **Act**ing.",
    "category": "agentic",
    "source": "notes/agentic/agent-reasoning-patterns-react-cot.md"
  },
  {
    "q": "How does ReAct differ from standard CoT?",
    "a": "CoT is for internal reasoning only. ReAct allows the model to **take actions** (call tools) and use the **observations** from those actions to inform the next reasoning step.",
    "category": "agentic",
    "source": "notes/agentic/agent-reasoning-patterns-react-cot.md"
  },
  {
    "q": "What is \"Zero-Shot CoT\"?",
    "a": "Triggering reasoning capabilities simply by appending the phrase \"**Let's think step by step**\" to the prompt, without providing examples.",
    "category": "agentic",
    "source": "notes/agentic/agent-reasoning-patterns-react-cot.md"
  },
  {
    "q": "What is the \"Observation\" step in the ReAct loop?",
    "a": "It is the output/result returned by an **external tool** (e.g., API response) that the model reads to update its context.",
    "category": "agentic",
    "source": "notes/agentic/agent-reasoning-patterns-react-cot.md"
  },
  {
    "q": "What is the main motivation for PEFT (Parameter-Efficient Fine-Tuning)?",
    "a": "To reduce the **computational and memory costs** of fine-tuning large models by updating only a small subset of parameters.",
    "category": "agentic",
    "source": "notes/agentic/llm-fine-tuning-lora-qlora.md"
  },
  {
    "q": "How does LoRA represent weight updates?",
    "a": "As the product of two **low-rank matrices** ($B \\times A$) added to the frozen base weights.",
    "category": "agentic",
    "source": "notes/agentic/llm-fine-tuning-lora-qlora.md"
  },
  {
    "q": "What is the advantage of merging LoRA weights for inference?",
    "a": "It eliminates any **latency overhead**; the model architecture remains identical to the original, just with updated weight values.",
    "category": "agentic",
    "source": "notes/agentic/llm-fine-tuning-lora-qlora.md"
  },
  {
    "q": "What does QLoRA add to standard LoRA?",
    "a": "It loads the frozen base model in **4-bit precision** (quantized), drastically reducing VRAM usage while maintaining performance.",
    "category": "agentic",
    "source": "notes/agentic/llm-fine-tuning-lora-qlora.md"
  },
  {
    "q": "What is \"Catastrophic Forgetting\"?",
    "a": "When a model forgets previously learned knowledge (e.g., how to speak English) while being fine-tuned on a new task (e.g., coding). PEFT mitigates this by freezing the base model.",
    "category": "agentic",
    "source": "notes/agentic/llm-fine-tuning-lora-qlora.md"
  },
  {
    "q": "Why is Accuracy a bad metric for CTR prediction?",
    "a": "Because of extreme **class imbalance** (CTR is very low), a model predicting all zeros would have high accuracy but zero value.",
    "category": "machine-learning",
    "source": "notes/machine-learning/adtech-metrics-auc-logloss-lift.md"
  },
  {
    "q": "What does AUC measure in the context of CTR?",
    "a": "It measures the probability that a random **click** is ranked higher than a random **non-click**. It evaluates **ranking quality**.",
    "category": "machine-learning",
    "source": "notes/machine-learning/adtech-metrics-auc-logloss-lift.md"
  },
  {
    "q": "What does LogLoss measure that AUC does not?",
    "a": "LogLoss measures **calibration** (how accurate the predicted probability values are), which is critical for calculating correct bids.",
    "category": "machine-learning",
    "source": "notes/machine-learning/adtech-metrics-auc-logloss-lift.md"
  },
  {
    "q": "What is the benefit of Normalized Entropy (NE) over LogLoss?",
    "a": "NE allows for comparison of model performance across datasets with **different average CTRs**.",
    "category": "machine-learning",
    "source": "notes/machine-learning/adtech-metrics-auc-logloss-lift.md"
  },
  {
    "q": "If a model has high AUC but high LogLoss, what does it mean?",
    "a": "The model ranks items correctly (good for sorting), but the probability values are incorrectly scaled (bad for pricing/bidding).",
    "category": "machine-learning",
    "source": "notes/machine-learning/adtech-metrics-auc-logloss-lift.md"
  },
  {
    "q": "What is the main problem with One-Hot Encoding for User IDs?",
    "a": "**High Cardinality**: The vector size becomes unmanageably large (millions of dimensions) and sparse.",
    "category": "machine-learning",
    "source": "notes/machine-learning/handling-sparse-data-embeddings-hashing-trick.md"
  },
  {
    "q": "How do Embeddings solve the sparsity problem?",
    "a": "They map high-dimensional sparse indices to **low-dimensional dense vectors** (e.g., size 64), which capture semantic relationships.",
    "category": "machine-learning",
    "source": "notes/machine-learning/handling-sparse-data-embeddings-hashing-trick.md"
  },
  {
    "q": "What is the \"Hashing Trick\"?",
    "a": "Mapping raw feature values to a fixed-size vector index using a hash function and modulo, avoiding the need for a vocabulary dictionary.",
    "category": "machine-learning",
    "source": "notes/machine-learning/handling-sparse-data-embeddings-hashing-trick.md"
  },
  {
    "q": "What is the main downside of the Hashing Trick?",
    "a": "**Hash Collisions**: Different features may map to the same index, causing noise (though models are often robust to this).",
    "category": "machine-learning",
    "source": "notes/machine-learning/handling-sparse-data-embeddings-hashing-trick.md"
  },
  {
    "q": "Why is the Hashing Trick useful for \"Crossed Features\"?",
    "a": "Crossed features (e.g., City x Job) have combinatorial cardinality; hashing keeps the memory usage constant regardless of the number of combinations.",
    "category": "machine-learning",
    "source": "notes/machine-learning/handling-sparse-data-embeddings-hashing-trick.md"
  },
  {
    "q": "What is the main goal of the \"Wide\" component in Wide & Deep?",
    "a": "To **memorize** specific feature co-occurrences (e.g., specific rules).",
    "category": "machine-learning",
    "source": "notes/machine-learning/ctr-prediction-models-deepfm-wide-deep.md"
  },
  {
    "q": "What is the main goal of the \"Deep\" component in Wide & Deep?",
    "a": "To **generalize** to unseen feature combinations using embeddings.",
    "category": "machine-learning",
    "source": "notes/machine-learning/ctr-prediction-models-deepfm-wide-deep.md"
  },
  {
    "q": "How does DeepFM improve upon Wide & Deep?",
    "a": "It replaces the manual feature engineering of the Wide part with a **Factorization Machine (FM)** to learn 2nd-order interactions automatically.",
    "category": "machine-learning",
    "source": "notes/machine-learning/ctr-prediction-models-deepfm-wide-deep.md"
  },
  {
    "q": "What is the shared input mechanism in DeepFM?",
    "a": "The FM component and the Deep component share the same **Embedding vectors** for the raw features.",
    "category": "machine-learning",
    "source": "notes/machine-learning/ctr-prediction-models-deepfm-wide-deep.md"
  },
  {
    "q": "Which architecture is typically used for the Retrieval stage (candidate generation)?",
    "a": "**Two-Tower** (or DSSM) architecture.",
    "category": "machine-learning",
    "source": "notes/machine-learning/ctr-prediction-models-deepfm-wide-deep.md"
  },
  {
    "q": "What is the goal of Multi-Armed Bandit algorithms?",
    "a": "To balance **Exploration** (gathering data) and **Exploitation** (maximizing reward) to minimize regret.",
    "category": "machine-learning",
    "source": "notes/machine-learning/multi-armed-bandits-thompson-sampling-ucb.md"
  },
  {
    "q": "How does Thompson Sampling select an arm?",
    "a": "It samples a random value from each arm's **posterior distribution** and picks the highest sample.",
    "category": "machine-learning",
    "source": "notes/machine-learning/multi-armed-bandits-thompson-sampling-ucb.md"
  },
  {
    "q": "What is the intuition behind UCB (Upper Confidence Bound)?",
    "a": "**Optimism in the face of uncertainty**: it favors arms that have a high potential (upper bound), either because they have a high average or because we don't know enough about them yet.",
    "category": "machine-learning",
    "source": "notes/machine-learning/multi-armed-bandits-thompson-sampling-ucb.md"
  },
  {
    "q": "How does Epsilon-Greedy handle exploration?",
    "a": "It chooses a completely random arm with a fixed probability $\\epsilon$ at every step.",
    "category": "machine-learning",
    "source": "notes/machine-learning/multi-armed-bandits-thompson-sampling-ucb.md"
  },
  {
    "q": "What is a Contextual Bandit?",
    "a": "A bandit algorithm that uses side information (Context/Features) about the user or environment to decide which arm is best for *that specific request*.",
    "category": "machine-learning",
    "source": "notes/machine-learning/multi-armed-bandits-thompson-sampling-ucb.md"
  },
  {
    "q": "What is the main limitation of Pointwise ranking loss?",
    "a": "It treats each item independently and penalizes errors at the bottom of the list equally to errors at the top, ignoring relative ordering.",
    "category": "machine-learning",
    "source": "notes/machine-learning/ranking-loss-functions-pointwise-pairwise-listwise.md"
  },
  {
    "q": "How does Pairwise ranking work?",
    "a": "It takes pairs of items (one positive, one negative) and trains the model to score the positive item higher than the negative one.",
    "category": "machine-learning",
    "source": "notes/machine-learning/ranking-loss-functions-pointwise-pairwise-listwise.md"
  },
  {
    "q": "What is BPR (Bayesian Personalized Ranking)?",
    "a": "A popular **Pairwise** loss function used in recommender systems that optimizes the relative order of positive vs. negative items.",
    "category": "machine-learning",
    "source": "notes/machine-learning/ranking-loss-functions-pointwise-pairwise-listwise.md"
  },
  {
    "q": "What is the goal of Listwise ranking?",
    "a": "To directly optimize the final ranking metric (like NDCG or MAP) considering the entire list of items at once.",
    "category": "machine-learning",
    "source": "notes/machine-learning/ranking-loss-functions-pointwise-pairwise-listwise.md"
  },
  {
    "q": "Which LTR approach is generally considered State-of-the-Art for tabular data (e.g., search engines)?",
    "a": "**LambdaMART** (a Listwise/Pairwise hybrid using Gradient Boosting).",
    "category": "machine-learning",
    "source": "notes/machine-learning/ranking-loss-functions-pointwise-pairwise-listwise.md"
  }
]